<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">

<channel>
  <title>Top Scirate Papers</title>
  <link>https://www.scirate.com</link>
  <description>The feed lists the top "scited" papers on the scirate website, often featuring the most widely appreciated quantum physics (quant-ph) preprints.</description>

  <item>
    <title>Learning to predict arbitrary quantum processes</title>
    <link>http://arxiv.org/pdf/2210.14894</link>
    <author>Hsin-Yuan Huang, Sitan Chen, John Preskill</author>
    <pubDate>Oct 27 2022</pubDate>
    <description>We present an efficient machine learning (ML) algorithm for predicting any unknown quantum process $\mathcal{E}$ over $n$ qubits. For a wide range of distributions $\mathcal{D}$ on arbitrary $n$-qubit states, we show that this ML algorithm can learn to predict any local property of the output from the unknown process $\mathcal{E}$, with a small average error over input states drawn from $\mathcal{D}$. The ML algorithm is computationally efficient even when the unknown process is a quantum circuit with exponentially many gates. Our algorithm combines efficient procedures for learning properties of an unknown state and for learning a low-degree approximation to an unknown observable. The analysis hinges on proving new norm inequalities, including a quantum analogue of the classical Bohnenblust-Hille inequality, which we derive by giving an improved algorithm for optimizing local Hamiltonians. Overall, our results highlight the potential for ML models to predict the output of complex quantum dynamics much faster than the time needed to run the process itself.</description>
  </item>

  <item>
    <title>Quantum state preparation without coherent arithmetic</title>
    <link>http://arxiv.org/pdf/2210.14892</link>
    <author>Sam McArdle, András Gilyén, Mario Berta</author>
    <pubDate>Oct 27 2022</pubDate>
    <description>We introduce a versatile method for preparing a quantum state whose amplitudes are given by some known function. Unlike existing approaches, our method does not require handcrafted reversible arithmetic circuits, or quantum memory loads, to encode the function values. Instead, we use a template quantum eigenvalue transformation circuit to convert a low cost block encoding of the sine function into the desired function. Our method uses only 4 ancilla qubits (3 if the approximating polynomial has definite parity), providing order-of-magnitude qubit count reductions compared to state-of-the-art approaches, while using a similar number of Toffoli gates if the function can be well represented by a polynomial or Fourier approximation. Like black-box methods, the complexity of our approach depends on the 'L2-norm filling-fraction' of the function. We demonstrate the efficiency of our method for preparing states commonly used in quantum algorithms, such as Gaussian and Kaiser window states.</description>
  </item>

  <item>
    <title>Uncloneable Cryptography</title>
    <link>http://arxiv.org/pdf/2210.14265</link>
    <author>Or Sattath</author>
    <pubDate>Oct 27 2022</pubDate>
    <description>The no-cloning theorem asserts that, unlike classical information, quantum information cannot be copied. This seemingly undesirable phenomenon is harnessed in quantum cryptography. Uncloneable cryptography studies settings in which the impossibility of copying is a desired property, and achieves forms of security that are classically unattainable. The first example discovered and analyzed was in the context of cash. On the one hand, we want users to hold the cash; on the other hand, the cash should be hard to counterfeit. Quantum money uses variants of the no-cloning theorem to make counterfeiting impossible. In the past decade, this field developed in various directions: several flavors of quantum money, such as classically verifiable, locally verifiable, semi-quantum, quantum coins, and quantum lightning were constructed. New uncloneable primitives were introduced, such as uncloneable signatures, quantum copy protection for classical software, pseudorandom states, and several uncloneable forms of encryption. This work is a gentle introduction to these topics.</description>
  </item>

  <item>
    <title>Functional Simulation of Real-Time Quantum Control Software</title>
    <link>http://arxiv.org/pdf/2210.14364</link>
    <author>Leon Riesebos, Kenneth R. Brown</author>
    <pubDate>Oct 27 2022</pubDate>
    <description>Modern quantum computers rely heavily on real-time control systems for operation. Software for these systems is becoming increasingly more complex due to the demand for more features and more real-time devices to control. Unfortunately, testing real-time control software is often a complex process, and existing simulation software is not usable or practical for software testing. For this purpose, we implemented an interactive simulator that simulates signals at the application programming interface level. We show that our simulation infrastructure simulates kernels 6.9 times faster on average compared to execution on hardware, while the position of the timeline cursor is simulated with an average accuracy of 97.9% when choosing the appropriate configuration.</description>
  </item>

  <item>
    <title>A classical oracle separation between QMA and QCMA</title>
    <link>http://arxiv.org/pdf/2210.15380</link>
    <author>Anand Natarajan, Chinmay Nirkhe</author>
    <pubDate>Oct 28 2022</pubDate>
    <description>It is a long-standing open question in quantum complexity theory whether the definition of $\textit{non-deterministic}$ quantum computation requires quantum witnesses $(\textsf{QMA})$ or if classical witnesses suffice $(\textsf{QCMA})$. We make progress on this question by constructing a randomized classical oracle separating the respective computational complexity classes. Previous separations [Aaronson-Kuperberg (CCC'07), Fefferman-Kimmel (MFCS'18)] required a quantum unitary oracle. The separating problem is deciding whether a distribution supported on regular un-directed graphs either consists of multiple connected components (yes instances) or consists of one expanding connected component (no instances) where the graph is given in an adjacency-list format by the oracle. Therefore, the oracle is a distribution over $n$-bit boolean functions.</description>
  </item>

</channel>

</rss>